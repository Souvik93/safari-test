!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@angular/core"),require("@angular/common")):"function"==typeof define&&define.amd?define(["exports","@angular/core","@angular/common"],e):e((t.ng2=t.ng2||{},t.ng2.gauge={}),t.ng.core,t.ng.common)}(this,function(t,e,n){"use strict";var r;!function(t){t[t.NA=0]="NA",t[t.Big=1]="Big",t[t.Small=2]="Small"}(r||(r={}));var a={WIDTH:200,ARC_STROKE:5,ARROW_Y:22.5,ARROW_WIDTH:4,ARROW_PIN_RAD:8,SL_NORM:3,SL_MID_SEP:7,SL_SEP:10,SL_WIDTH:2,TXT_MARGIN:10,LIGHT_Y:55,LIGHT_RADIUS:10,S_FAC_Y:80,DIGITAL_Y:145,UNIT_Y:155,MAX_PURE_SCALE_VAL:1e3,INIT_LINE_FREQ:2,DEF_START:225,DEF_END:135},o=function(t){console.error("GaugeComponent: "+t)},i=function(t){t.max||o("The maximal value is not set."),0<=t.start&&t.start<=359&&0<=t.end&&t.end<=359||o("The end and start must be between 0 and 359 degrees."),t.light&&t.light>t.max&&o("The red light trigger value cannot be greater than the max value of the gauge."),t.factor&&t.factor>=t.max&&o("The factor cannot be greater than or equal to the max value."),t.sectors&&t.sectors.forEach(function(e){(e.from>t.max||e.to>t.max)&&o("The sector bounds cannot be greater than the max value."),e.from>=e.to&&o("The lower bound of the sector cannot be greater than or equal to the upper one."),e.color||o("Sector["+e.from+", "+e.to+"] color is empty.")})},s=function(){function t(t){this._renderer=t,this.start=a.DEF_START,this.end=a.DEF_END,this.Config=a,this.scaleLines=[],this.scaleValues=[]}return Object.defineProperty(t.prototype,"input",{get:function(){return this._input},set:function(t){this._input=t,this._updateArrowPos(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"arc",{get:function(){return this._arc(0,this._end)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"gaugeRotationAngle",{get:function(){return this._end-this.end},enumerable:!0,configurable:!0}),t.prototype.ngOnInit=function(){i(this);var t=a.WIDTH+a.ARC_STROKE;this.viewBox="0 0 "+t+" "+t,this.radius=a.WIDTH/2,this.center=t/2,this._end=this.end,this.start>this.end?this._end+=360-this.start:this._end-=this.start,this._updateArrowPos(this._input),this._calculateSectors(),this.scaleFactor=this.factor||this._determineScaleFactor(),this._createScale()},t.prototype.ngAfterViewInit=function(){this._rotateGauge()},t.prototype._arc=function(t,e){var n=e-t<=180?0:1,r=this._getAngleCoor(t),a=this._getAngleCoor(e);return"M "+a.x+" "+a.y+" A "+this.radius+" "+this.radius+" 0 "+n+" 0 "+r.x+" "+r.y},t.prototype._getAngleCoor=function(t){var e=(t-90)*Math.PI/180;return{x:this.radius*Math.cos(e)+this.center,y:this.radius*Math.sin(e)+this.center}},t.prototype._calculateSectors=function(){var t=this;this.sectors&&(this.sectors=this.sectors.map(function(e){var n=t._end/t.max;return e.from*=n,e.to*=n,e}),this.sectorArcs=this.sectors.map(function(e){return{path:t._arc(e.from,e.to),color:e.color}}))},t.prototype._updateArrowPos=function(t){var e=this._end/this.max*t;this._renderer.setStyle(this.arrow.nativeElement,"transform","rotate("+e+"deg)")},t.prototype._rotateGauge=function(){var t=360-this.start;this._renderer.setStyle(this.gauge.nativeElement,"transform","rotate(-"+t+"deg)")},t.prototype._determineScaleFactor=function(t){return void 0===t&&(t=10),this.max/t>30?this._determineScaleFactor(10*t):t},t.prototype._determineLineFrequency=function(){var t,e=this.max/this.scaleFactor,n=this._end/e;if(n%1!=0)t=n;else for(t=2*a.INIT_LINE_FREQ;t<=n&&n%t!=0;t++);return t},t.prototype._isSeparatorReached=function(t,e){var n=this.max/this.scaleFactor,a=this._end/e/n;return t%a==0?r.Big:t%(a/2)==0?r.Small:r.NA},t.prototype._createScale=function(){for(var t=this._determineLineFrequency()/2,e=this.max/this.scaleFactor>10,n=0,o=0,i=0;o>=-1*this._end;o-=t,i++){var s=a.SL_NORM,c=this._isSeparatorReached(i,t);switch(c){case r.Big:n++,s=a.SL_SEP;break;case r.Small:s=a.SL_MID_SEP}var l=this.center-a.ARC_STROKE-2,g=l-s,u=Math.PI/180*(o+180),h=Math.sin(u),f=Math.cos(u),p=this._getScaleLineColor(o);if(this._addScaleLine(h,f,l,g,p),c===r.Big){var _=n%2==0,d=o<=-1*this._end;e&&_&&!d||this._addScaleValue(h,f,g,o)}}},t.prototype._getScaleLineColor=function(t){t*=-1;var e="";return this.sectors&&this.sectors.forEach(function(n){n.from<=t&&t<=n.to&&(e=n.color)}),e},t.prototype._addScaleLine=function(t,e,n,r,a){this.scaleLines.push({from:{x:t*n+this.center,y:e*n+this.center},to:{x:t*r+this.center,y:e*r+this.center},color:a})},t.prototype._addScaleValue=function(t,e,n,r){var o=-1*Math.round(r*(this.max/this._end)),i=2*a.TXT_MARGIN;this.max>a.MAX_PURE_SCALE_VAL&&(o/=this.scaleFactor,o=Math.round(100*o)/100,i/=2),this.scaleValues.push({text:o.toString(),coor:{x:t*(n-i)+this.center,y:e*(n-i)+this.center}})},t.decorators=[{type:e.Component,args:[{selector:"ng-gauge",template:'\n    <section class="angular-gauge" [class.light]="lightTheme">\n      <svg class="info" [attr.viewBox]="viewBox" xmlns="http://www.w3.org/2000/svg">\n        <circle *ngIf="light"\n          class="red-light"\n          [class.on]="input >= light"\n          [attr.cx]="center"\n          [attr.cy]="Config.LIGHT_Y"\n          [attr.r]="Config.LIGHT_RADIUS">\n        </circle>\n        <text *ngIf="max > Config.MAX_PURE_SCALE_VAL"\n          class="factor"\n          [attr.x]="center"\n          [attr.y]="Config.S_FAC_Y">\n          x{{scaleFactor}} {{unit}}\n        </text>\n        <text *ngIf="showDigital"\n          class="digital"\n          [attr.x]="center"\n          [attr.y]="Config.DIGITAL_Y">\n          {{input}}\n        </text>\n        <text class="unit" [attr.x]="center" [attr.y]="Config.UNIT_Y">{{unit}}</text>\n      </svg>\n      <svg #gauge [attr.viewBox]="viewBox" xmlns="http://www.w3.org/2000/svg">\n        <path class="main-arc" [attr.d]="arc" [attr.stroke-width]="Config.ARC_STROKE" fill="none" />\n        <path *ngFor="let arc of sectorArcs"\n          [attr.d]="arc.path"\n          [attr.stroke]="arc.color"\n          [attr.stroke-width]="Config.ARC_STROKE"\n          fill="none" />\n        <line *ngFor="let line of scaleLines"\n          [attr.stroke-width]="Config.SL_WIDTH"\n          [attr.stroke]="line.color || (!lightTheme ? \'#333\' : \'#fff\')"\n          [attr.x1]="line.from.x"\n          [attr.y1]="line.from.y"\n          [attr.x2]="line.to.x"\n          [attr.y2]="line.to.y" />\n        <text *ngFor="let val of scaleValues"\n          class="text-val"\n          dominant-baseline="central"\n          [attr.x]="val.coor.x"\n          [attr.y]="val.coor.y"\n          [attr.transform]="\'rotate(\' + gaugeRotationAngle + \', \' + val.coor.x + \', \' + val.coor.y + \')\'">\n          {{val.text}}\n        </text>\n        <rect #arrow\n          class="arrow"\n          [attr.x]="center - Config.ARROW_WIDTH / 2"\n          [attr.y]="Config.ARROW_Y"\n          [attr.height]="center - Config.ARROW_Y"\n          [attr.width]="Config.ARROW_WIDTH"\n          [attr.rx]="Config.ARROW_WIDTH / 2"\n          [attr.ry]="Config.ARROW_WIDTH / 2">\n        </rect>\n        <circle class="arrow-pin" [attr.cx]="center" [attr.cy]="center" [attr.r]="Config.ARROW_PIN_RAD" />\n      </svg>\n    </section>\n  ',styles:["\n    @font-face {\n      font-family: 'Orbitron';\n      font-style: normal;\n      font-weight: 700;\n      src: local('Orbitron Bold'), local('Orbitron-Bold'), url(https://fonts.gstatic.com/s/orbitron/v8/Y82YH_MJJWnsH2yUA5AuYY4P5ICox8Kq3LLUNMylGO4.woff2) format('woff2');\n      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215;\n    }\n\n    .angular-gauge {\n      position: relative;\n      width: 400px;\n    }\n\n    .angular-gauge svg.info {\n      position: absolute;\n      top: 0;\n      left: 0;\n    }\n\n    .angular-gauge rect.arrow {\n      transform-origin: 50% 100%;\n      fill: orange;\n    }\n\n    .angular-gauge text {\n      font-family: 'Orbitron', sans-serif;\n      font-weight: bold;\n      text-anchor: middle;\n      fill: #333;\n    }\n\n    .angular-gauge.light text {\n      fill: #fff;\n    }\n\n    .angular-gauge text.text-val {\n      font-size: 12px;\n    }\n\n    .angular-gauge circle.arrow-pin {\n      fill: #333;\n    }\n\n    .angular-gauge path.main-arc {\n      stroke: #333;\n    }\n\n    .angular-gauge.light path.main-arc {\n      stroke: #fff;\n    }\n\n    .angular-gauge text.factor {\n      font-size: 7px;\n    }\n\n    .angular-gauge text.digital {\n      font-size: 16px;\n    }\n\n    .angular-gauge text.unit {\n      font-size: 10px;\n    }\n\n    .angular-gauge circle.red-light {\n      fill: #ff4f4f;\n      opacity: 0.1;\n    }\n\n    .angular-gauge circle.red-light.on {\n      opacity: 1;\n    }\n\n  "],encapsulation:e.ViewEncapsulation.None}]}],t.ctorParameters=function(){return[{type:e.Renderer2}]},t.propDecorators={gauge:[{type:e.ViewChild,args:["gauge"]}],arrow:[{type:e.ViewChild,args:["arrow"]}],start:[{type:e.Input}],end:[{type:e.Input}],max:[{type:e.Input}],sectors:[{type:e.Input}],unit:[{type:e.Input}],showDigital:[{type:e.Input}],light:[{type:e.Input}],lightTheme:[{type:e.Input}],factor:[{type:e.Input}],config:[{type:e.Input}],input:[{type:e.Input}]},t}(),c=function(){function t(){}return t.decorators=[{type:e.NgModule,args:[{imports:[n.CommonModule],declarations:[s],exports:[s]}]}],t.ctorParameters=function(){return[]},t}();t.GaugeModule=c,t.GaugeComponent=s,Object.defineProperty(t,"__esModule",{value:!0})});